/*
 **************************************************************************
 *          
 *             N o r t h w e s t e r n     U n i v e r s i t y             
 *                                                                         
 * Hamsa - Polymorphic Worm Signature Generation Project -- Zhichun Li     
 *                                                       -- Mananan Sanghi 
 *                                                       -- Brian Chavez   
 *                                                       -- Yan Chen       
 *                                                       -- Ming-Kang Kao  
 *                                                                         
 * FILE:     sig_gen.cpp 
 * DATE:     October 31, 2005                                              
 * AUTHOR:   Zhichun Li, lizc@cs.northwestern.edu                      
 * PROJECT:  Hamsa                                                         
 *              
 *                                                                         
 * The Northwestern University
 * All rights reserved.
 * Redistribution in source and binary forms, with or without
 * modification, are NOT permitted without permission from the authors:
 *
 * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  
 */
#include <string.h>
#include <unistd.h>

#include <fstream>
#include <iostream>
#include <algorithm>
#include <string>
#include <vector>
#include <list>

#include "globals.h"
#include "bitvec.h"
#include "tokenExtract.h"
#include "conjpattern.h"
#include "calscore.h"

using namespace std;


vector<ConjPattern*> allsigs;

ConjPattern *gen_onesig(vector<Tokenobj*> & tklist, list<TraceSary*> & normallist, unsigned int min_covth);
bool greater_ptnref(ConjPattern* t1, ConjPattern* t2);
bool greater_tokenref(Tokenobj* t1, Tokenobj* t2);
void gen_sig_iter(list<string*> & sample, unsigned int min_residue, double coverage,list<TraceSary*> & normallist);
void gen_sig (vector<ConjPattern*> & sigs, list<string*> & sample, unsigned int min_residue, double coverage
	,list<TraceSary*> & normallist);
void remv_sarymatched(list<string*> & remain,list<string*> & matched,list<string*> & sample,ConjPattern *sig);
void rm_redundance(ConjPattern *sig);
ConjPattern * best_sig(list<string*> & sample);




void remv_sarymatched(list<string*> & remain,list<string*> & matched,list<string*> & sample,ConjPattern *sig)
{
	list<string*>::iterator liter;
	//unsigned int count=0;
	unsigned int i=0;

//	cerr << "ENTER:" <<__FUNCTION__ <<endl;
/* this function to be correct depend on many things:
 * 1) the order of sample, maybe vector better
 * 2) the order of the sampleID, generated by Brian
 * keep it for now, may change list to vector
 */
	for (liter=sample.begin(); liter!=sample.end(); ++liter)
	{
		if (sig->covvec->testbit(i))
		{
			matched.push_back(*liter);
		} else {
			remain.push_back(*liter);
		}
		i++;
	}
}

void rm_redundance(ConjPattern *sig)
{
	vector<Tokenobj> tmptklist;
	vector<Tokenobj>::iterator vtiter;

//	cerr << "ENTER:" <<__FUNCTION__ <<endl;
	for (vtiter=sig->tokens.begin(); vtiter!=sig->tokens.end(); ++vtiter)
	{
		vtiter->score=1;
	}

	unsigned int i, j, num=sig->tokens.size();

	for (i=0; i<num; i++)
	{
		if (sig->tokens[i].score)
		{
			for (j=0; j<num; j++)
			{
				if (sig->tokens[i].issuperset(&(sig->tokens[j]))) sig->tokens[j].score=0;
			}
		}
	}

	for (vtiter=sig->tokens.begin(); vtiter!=sig->tokens.end(); ++vtiter)
	{
		if (vtiter->score)
		{
			tmptklist.push_back(*vtiter);
		}

	}

	sig->tokens.swap(tmptklist);
}

ConjPattern * best_sig(list<string*> & sample)
{
//	cerr << "ENTER:" <<__FUNCTION__ <<endl;
	vector<Tokenobj> tklist;
	vector<Tokenobj>::iterator viter;
	ConjPattern * sig = new ConjPattern();

	//todo unfinished : think about the API
	SusTrace * suspool= new SusTrace(sample);
	//printf("best pool length=%u, numsample=%u\n",suspool->length,suspool->numsample);
	suspool->extract_uniptn(tklist,min_token_len);
	delete suspool;

	sig->tokens.swap(tklist);

	rm_redundance(sig);

	return sig;
}


void gen_sig (vector<ConjPattern*> & sigs, list<string*> & sample, unsigned int min_residue, double coverage
	,list<TraceSary*> & normallist)
{
	
//	cerr << "ENTER:" <<__FUNCTION__ <<endl;
	allsigs.clear();
	totalnumsample=sample.size();

	//printf("Totalnumsample=%u\n",totalnumsample);

	gen_sig_iter(sample,min_residue,coverage,normallist);

	sigs.clear();
	sigs.swap(allsigs);
	
}

void gen_sig_iter(list<string*> & sample, unsigned int min_residue, double coverage,list<TraceSary*> & normallist)
{
	ConjPattern *bestsig;

	unsigned int numsample=sample.size();
	unsigned int covth = max(min_residue,(unsigned int)(numsample*coverage));

	if (numsample<=covth) return;

//	cerr << "ENTER:" <<__FUNCTION__ <<endl;
	cout << "=======================================================" << endl;
	cout << "RESIDUE SIZE: " << numsample << endl;
	cout << "=======================================================" << endl;

	vector<Tokenobj*> tklist;
	vector<Tokenobj*>::iterator viter;

	//todo 
	SusTrace * suspool= new SusTrace(sample);
	suspool->extract_ptntoken(tklist,min_token_len, max(covth,min_cov_token));
	//printf("greedy pool length=%u, numsample=%u\n",suspool->length,suspool->numsample);
	delete suspool;

	ConjPattern *sig;
	sig=gen_onesig(tklist, normallist,min_residue);
		
	for (viter=tklist.begin(); viter!=tklist.end(); ++viter)
	{
		delete (*viter);
		(*viter)=NULL;
	}
	tklist.clear();

	if (sig!=NULL)
	{
		if (Gtestcache) flushcache();
		Gage++;


		cout << "THE GREEDY SIG:" <<endl;
		sig->printme();
		cout <<endl;

		list<string*>remain;
		list<string*>matched;
		remain.clear();
		matched.clear();
		remv_sarymatched(remain,matched,sample,sig);

		bestsig=best_sig(matched);
		cout << "THE BEST SIG:" <<endl;
		bestsig->printme();
		cout << endl;
		allsigs.push_back(bestsig);
		delete sig;
		sig=NULL;
		matched.clear();
		gen_sig_iter(remain,min_residue,coverage,normallist);
	}

	sample.clear();
	
	
}

bool greater_tokenref(Tokenobj* t1, Tokenobj* t2)
{
	return (t1->score > t2->score);
}

bool greater_ptnref(ConjPattern* t1, ConjPattern* t2)
{
	return (t1->score > t2->score);
}

ConjPattern *gen_onesig(vector<Tokenobj*> & tklist, list<TraceSary*> & normallist, unsigned int min_covth)
{
	ConjPattern *newcanptn, *canptn;
	unsigned int tokencnt=0;
	bool unfinish=true;
	vector<ConjPattern*> siglist;
	siglist.clear();

//	cerr << "ENTER:" <<__FUNCTION__ <<endl;

	if (tklist.size()==0) {
		return NULL;
	} else if (tklist.size()==1) {
		tklist[0]->testfp(normallist);
		if (tklist[0]->fpos>=Gfinalfp) {
			return NULL;
		} else {
			newcanptn= new ConjPattern(tklist[0]);
			return newcanptn;
		}
	} 

	unsigned int kstar=min(GKbound,tklist.size());

	//cout << "KSTAR=" <<kstar <<endl;

	vector<Tokenobj*>::iterator vtiter;
	for (vtiter=tklist.begin(); vtiter!=tklist.end(); ++vtiter)
	{
		(*vtiter)->score=(*vtiter)->cov;
	}
	sort(tklist.begin(),tklist.end(),greater_tokenref);

	canptn=NULL;
	for (vtiter=tklist.begin(); vtiter!=tklist.end(); ++vtiter)
	{
		(*vtiter)->testfp(normallist);
		if ((*vtiter)->fpos <=GUbound[0])
		{
			canptn= new ConjPattern(*vtiter);
			tklist.erase(vtiter);
			break;
		}
	}
	
	if (canptn==NULL) return NULL;

	cout <<"STEP 1 SIG:" <<endl;
	canptn->printme();
	

	tokencnt=1;
	unfinish=true;
	siglist.push_back(canptn);
	double jpos;

	while ((tokencnt<kstar) && (unfinish))
	{
		tokencnt++;

		newcanptn=NULL;
		for (vtiter=tklist.begin(); vtiter!=tklist.end(); ++vtiter)
		{
			(*vtiter)->score=canptn->testjoincov(*vtiter);
		}
		sort(tklist.begin(),tklist.end(),greater_tokenref);

		for (vtiter=tklist.begin(); vtiter!=tklist.end(); ++vtiter)
		{
			if (not canptn->istkinclude(*vtiter))
			{
				(*vtiter)->testfp(normallist);
				jpos=canptn->testjoinfp(*vtiter);
				if (jpos<=GUbound[tokencnt-1])
				{
					newcanptn= new ConjPattern(canptn,(*vtiter));
					tklist.erase(vtiter);
					break;
				}

			}
		}


		//todo: not sure whether this condition can work
		if ((newcanptn == NULL) || (newcanptn->cov<min_covth))
		{
			unfinish=false;
			if (newcanptn!=NULL)
			{
				delete newcanptn;
				newcanptn=NULL;
			}
		
		} else {
			canptn=newcanptn;
			siglist.push_back(canptn);
			cout <<"STEP " <<tokencnt <<" SIG:" <<endl;
			canptn->printme();
		
		}


	}

	vector<ConjPattern*>::iterator lsiter;
	vector<ConjPattern*> newsiglist;
	newsiglist.clear();

	for (lsiter=siglist.begin(); lsiter!=siglist.end(); ++lsiter)
	{
		if (((*lsiter)->cov>=min_covth) && ((*lsiter)->fpos<Gfinalfp))
		{
			newsiglist.push_back(*lsiter);
		}
	}

	if (newsiglist.size()==0) return NULL;

	for (lsiter=newsiglist.begin(); lsiter!=newsiglist.end(); ++lsiter)
	{
		(*lsiter)->score=calscore((*lsiter)->cov,(*lsiter)->fpos,(*lsiter)->length(),totalnumsample);
	}
	sort(newsiglist.begin(),newsiglist.end(),greater_ptnref);

	ConjPattern *best= new ConjPattern(newsiglist[0]);
	//release all the ptn in siglist;
	for (lsiter=siglist.begin(); lsiter!=siglist.end(); ++lsiter)
	{
		delete (*lsiter);
		(*lsiter)=NULL;
	}



	return best;


}

	


